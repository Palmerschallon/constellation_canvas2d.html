<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Constellation of Grief &amp; Rebirth — Canvas2D Movie</title>
<style>
  html, body { margin:0; padding:0; background:#000; height:100%; }
  #wrap { position:fixed; inset:0; display:grid; place-items:center; background:#000; }
  canvas { width: min(92vmin, 1200px); height: min(92vmin, 1200px); image-rendering: -webkit-optimize-contrast; }
  .caption { 
    position: fixed; left: 50%; transform: translateX(-50%); 
    bottom: 4vh; width: min(86vmin, 1100px); color:#f0f0f0; 
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; 
    line-height:1.35; letter-spacing:0.2px; font-size: clamp(12px, 2.1vmin, 22px);
    text-shadow: 0 1px 4px rgba(0,0,0,0.8), 0 0 16px rgba(255,180,150,0.15);
    text-align: center; 
    padding: 0.8em 1em; border-radius: 10px;
    background: linear-gradient( to top, rgba(0,0,0,0.55), rgba(0,0,0,0.15) );
    user-select: none;
  }
  .hud {
    position:fixed; top:10px; left:10px; color:#aaa; font: 12px/1.2 monospace;
    background: rgba(0,0,0,0.35); padding: 6px 8px; border-radius: 6px;
  }
  .controls {
    position: fixed; top:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap;
  }
  .btn {
    color:#ddd; font: 12px/1 monospace; background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.12); padding:6px 10px; border-radius:6px; cursor:pointer;
  }
  .btn:hover{ background: rgba(255,255,255,0.12); }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>
<div class="caption" id="caption"></div>
<div class="hud" id="hud"></div>
<div class="controls">
  <button class="btn" id="playPause">pause</button>
  <button class="btn" id="toggleText">hide text</button>
  <button class="btn" id="prevScene">prev</button>
  <button class="btn" id="nextScene">next</button>
</div>

<script>
(() => {
  const DPR = Math.min(devicePixelRatio || 1, 2);
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const CAPTION = document.getElementById('caption');
  const HUD = document.getElementById('hud');

  function resize() {
    const side = Math.min(window.innerWidth, window.innerHeight) * 0.92;
    const pix = Math.min(1600, Math.max(700, Math.floor(side))) | 0;
    canvas.width = pix * DPR;
    canvas.height = pix * DPR;
  }
  resize();
  window.addEventListener('resize', resize);

  const LEGEND = [
    {title: "Flight", text: "Birds carry messages across the dark. Blue jay dress, blue heel flare—grief learns a wingbeat."},
    {title: "Beams", text: "Unseen supports hold the house until they crack. Love is a hidden joist. Motherhood is load-bearing."},
    {title: "Drowned Coast", text: "Shipwreck water devours and baptizes. To be taken under and brought back shining."},
    {title: "Lens", text: "Witness is a lens: red carpet flash, bird glass, phone raised in the alley—you are here."},
    {title: "Signs", text: "Omen is an alphabet: cardinals, fungi, blacklight stones. Read the random; make a grammar of it."},
    {title: "Exile Hearth", text: "Motherhood is exile and anchor, a small fire in a wide night. The body charges the world."},
    {title: "Error → Rebirth", text: "Failure-to-progress was a verdict. Recompile. New self boots, breath by breath."}
  ];

  const SCENES = [];
  let TIME = 0;
  let sceneIndex = 0;
  let playing = true;
  let showText = true;

  let TARGET = 10000;
  if (/iPhone|Android/i.test(navigator.userAgent)) TARGET = 7000;
  if (DPR > 1.5) TARGET = Math.floor(TARGET * 0.8);

  class Ember {
    constructor() { this.reset(true); }
    reset(randomXY = false) {
      const W = canvas.width, H = canvas.height;
      this.x = randomXY ? Math.random()*W : (W*0.5 + (Math.random()-0.5)*W*0.2);
      this.y = randomXY ? Math.random()*H : (H*0.5 + (Math.random()-0.5)*H*0.2);
      this.vx = (Math.random()-0.5) * 0.25 * DPR;
      this.vy = (Math.random()-0.5) * 0.25 * DPR;
      this.base = Math.random()**2;
      this.a = this.base;
      this.r = 0.7 + this.base * 2.5;
      this.hue = 20 + 25 * (1 - this.base);
      this.life = 0;
    }
    step(ax=0, ay=0, drag=0.995) {
      this.vx = (this.vx + ax) * drag;
      this.vy = (this.vy + ay) * drag;
      this.x += this.vx;
      this.y += this.vy;
      this.life += 1;
      const W = canvas.width, H = canvas.height;
      if (this.x < 0) this.x += W; else if (this.x > W) this.x -= W;
      if (this.y < 0) this.y += H; else if (this.y > H) this.y -= H;
      this.a = Math.max(0, Math.min(1, this.base + (Math.random()-0.5)*0.2));
    }
    drawGlow() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*DPR, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${this.hue},80%,60%,${0.12*this.a})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*0.6*DPR, 0, Math.PI*2);
      ctx.fillStyle = `hsla(${40 + this.hue*0.2},90%,80%,${0.15*this.a})`;
      ctx.fill();
    }
  }

  const EMBERS = new Array(TARGET).fill(0).map(_ => new Ember());

  function vignette(alpha=0.2) {
    const W = canvas.width, H = canvas.height;
    const g = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.1, W/2, H/2, Math.max(W,H)*0.5);
    g.addColorStop(0, `rgba(0,0,0,${alpha*0.2})`);
    g.addColorStop(1, `rgba(0,0,0,${alpha})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  function drawCaption() {
    if (!showText) { CAPTION.innerHTML = ""; return; }
    const L = LEGEND[sceneIndex % LEGEND.length];
    CAPTION.innerHTML = `<b>${L.title}</b> — ${L.text}`;
  }

  // Scene 0: Flight
  (function(){
    const gravityUp = -0.003 * DPR;
    SCENES.push({
      name: "Flight",
      enter(){ drawCaption(); },
      frame(t, dt){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'lighter';

        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          const angle = t*0.0003;
          const ox = canvas.width*0.5 + Math.cos(angle)*canvas.width*0.18;
          const oy = canvas.height*0.5 + Math.sin(angle*1.3)*canvas.height*0.18;
          let dx = ox - e.x, dy = oy - e.y;
          const dist = Math.hypot(dx, dy) + 0.0001;
          dx/=dist; dy/=dist;
          e.step(dx*0.02, gravityUp + dy*0.02, 0.996);
          e.drawGlow();
        }
        vignette(0.2);
      }
    });
  })();

  // Scene 1: Beams
  (function(){
    const beams = [];
    function makeBeams(){
      beams.length = 0;
      const W = canvas.width, H = canvas.height;
      const count = 14;
      for (let i=0;i<count;i++){
        const x = (i+1)/(count+1) * W;
        beams.push({x, phase: Math.random()*Math.PI*2, w: 2 + Math.random()*4});
      }
    }
    SCENES.push({
      name: "Beams",
      enter(){ makeBeams(); drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.18)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        for (const b of beams){
          const pulse = (Math.sin(t*0.002 + b.phase)*0.5 + 0.5);
          const lw = (b.w + pulse*6) * DPR;
          const g = ctx.createLinearGradient(b.x, 0, b.x, H);
          g.addColorStop(0, 'rgba(255,220,120,0.0)');
          g.addColorStop(0.5, 'rgba(255,220,160,0.12)');
          g.addColorStop(1, 'rgba(255,120,80,0.0)');
          ctx.strokeStyle = g;
          ctx.lineWidth = lw;
          ctx.beginPath();
          ctx.moveTo(b.x, 0);
          ctx.lineTo(b.x, H);
          ctx.stroke();
        }

        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          const ix = Math.round((e.x/W) * beams.length);
          const bx = beams[Math.max(0, Math.min(beams.length-1, ix))].x;
          const dx = bx - e.x;
          e.step(dx*0.002, -0.001*DPR, 0.994);
          e.drawGlow();
        }
        vignette(0.25);
      }
    });
  })();

  // Scene 2: Drowned Coast
  (function(){
    SCENES.push({
      name: "Drowned Coast",
      enter(){ drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,10,25,0.18)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          const n = Math.sin((e.x*0.006 + t*0.0012)) * Math.cos((e.y*0.006 - t*0.0010));
          const ax = n * 0.015;
          const ay = Math.sin((e.x + e.y + t*0.2)*0.002) * 0.003 - 0.0005;
          e.hue = 200 + 50*(1 - e.base);
          e.step(ax, ay, 0.997);
          e.drawGlow();
        }
        vignette(0.25);
      }
    });
  })();

  // Scene 3: Lens
  (function(){
    let flash = 0;
    SCENES.push({
      name: "Lens",
      enter(){ flash = 1.0; drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          e.step(0.0005, -0.00025, 0.998);
          e.drawGlow();
        }

        if (Math.random() < 0.02) flash = 1.0;
        if (flash > 0) {
          const g = ctx.createRadialGradient(W*0.52, H*0.48, 10, W*0.5, H*0.5, Math.max(W,H)*0.6);
          g.addColorStop(0, `rgba(255,255,255,${0.35*flash})`);
          g.addColorStop(1, `rgba(255,255,255,0)`);
          ctx.fillStyle = g;
          ctx.fillRect(0,0,W,H);
          flash *= 0.88;
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1 * DPR;
        const s = Math.min(W,H) * (0.25 + 0.05*Math.sin(t*0.001));
        const cx = W/2, cy = H/2;
        ctx.strokeRect(cx - s/2, cy - s/2, s, s);
        ctx.globalCompositeOperation = 'lighter';

        vignette(0.18);
      }
    });
  })();

  // Scene 4: Signs
  (function(){
    SCENES.push({
      name: "Signs",
      enter(){ drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.16)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          e.step(0.0, -0.0003, 0.998);
        }

        ctx.strokeStyle = 'rgba(255,210,140,0.08)';
        ctx.lineWidth = 1 * DPR;
        for (let i=0;i<EMBERS.length; i+=80){
          const e = EMBERS[i];
          let best = null, bestD = 1e9;
          for (let k=0;k<6;k++){
            const j = (i + Math.floor(Math.random()*500)) % EMBERS.length;
            const f = EMBERS[j];
            const d = (e.x - f.x)**2 + (e.y - f.y)**2;
            if (d < bestD) { bestD = d; best = f; }
          }
          if (best && bestD < (Math.min(W,H)*0.18)**2){
            ctx.beginPath();
            ctx.moveTo(e.x, e.y);
            ctx.lineTo(best.x, best.y);
            ctx.stroke();
          }
        }
        for (let i=0;i<EMBERS.length;i++) EMBERS[i].drawGlow();

        vignette(0.22);
      }
    });
  })();

  // Scene 5: Exile Hearth
  (function(){
    SCENES.push({
      name: "Exile Hearth",
      enter(){ drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(20,10,0,0.16)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        const ox = W*0.5, oy = H*0.5;
        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          let dx = ox - e.x, dy = oy - e.y;
          const d = Math.hypot(dx, dy) + 0.0001;
          dx/=d; dy/=d;
          e.hue = 30 + 30*(1 - e.base);
          e.step(dx*0.01, dy*0.01, 0.995);
          e.drawGlow();
        }

        const g = ctx.createRadialGradient(ox, oy, 0, ox, oy, Math.min(W,H)*0.35);
        g.addColorStop(0, 'rgba(255,180,120,0.14)');
        g.addColorStop(1, 'rgba(255,120,80,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);

        vignette(0.20);
      }
    });
  })();

  // Scene 6: Error -> Rebirth
  (function(){
    SCENES.push({
      name: "Error→Rebirth",
      enter(){ drawCaption(); },
      frame(t, dt){
        const W = canvas.width, H = canvas.height;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.14)';
        ctx.fillRect(0,0,W,H);
        ctx.globalCompositeOperation = 'lighter';

        const cx = W/2, cy = H/2;
        const rot = (t*0.0007) % (Math.PI*2);
        for (let i=0;i<EMBERS.length;i++){
          const e = EMBERS[i];
          const a = rot + (i/EMBERS.length)*Math.PI*8;
          const r = (Math.min(W,H)*0.1) + ((i%200)/200) * Math.min(W,H)*0.35;
          const tx = cx + Math.cos(a) * r;
          const ty = cy - (t*0.05 % H) + Math.sin(a) * r * 0.2;
          const dx = (tx - e.x) * 0.0025;
          const dy = (ty - e.y) * 0.0025;
          e.step(dx, dy, 0.996);
          e.hue = 40 + 200 * (i/EMBERS.length);
          e.drawGlow();
        }
        vignette(0.18);
      }
    });
  })();

  let last = performance.now();
  let sceneTimer = 0;
  const SCENE_LENGTH = 9000;
  drawCaption();

  function loop(now){
    const dt = now - last; last = now;
    if (playing) {
      TIME += dt;
      sceneTimer += dt;
      const scene = SCENES[sceneIndex % SCENES.length];
      scene.frame(TIME, dt);
      if (sceneTimer > SCENE_LENGTH) {
        sceneIndex = (sceneIndex + 1) % SCENES.length;
        sceneTimer = 0;
        SCENES[sceneIndex].enter?.();
      }
      if (dt > 50 && EMBERS.length > 4000) {
        EMBERS.length = Math.max(4000, Math.floor(EMBERS.length * 0.9));
      }
    }
    HUD.textContent = `scene: ${SCENES[sceneIndex].name}  |  embers: ${EMBERS.length}  |  dpr: ${DPR.toFixed(2)}`;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  document.getElementById('playPause').onclick = () => {
    playing = !playing;
    document.getElementById('playPause').textContent = playing ? 'pause' : 'play';
  };
  document.getElementById('toggleText').onclick = () => {
    showText = !showText;
    document.getElementById('toggleText').textContent = showText ? 'hide text' : 'show text';
    drawCaption();
  };
  document.getElementById('nextScene').onclick = () => {
    sceneIndex = (sceneIndex + 1) % SCENES.length;
    sceneTimer = 0;
    SCENES[sceneIndex].enter?.();
  };
  document.getElementById('prevScene').onclick = () => {
    sceneIndex = (sceneIndex - 1 + SCENES.length) % SCENES.length;
    sceneTimer = 0;
    SCENES[sceneIndex].enter?.();
  };

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); document.getElementById('playPause').click(); }
    if (e.key === 'ArrowRight') document.getElementById('nextScene').click();
    if (e.key === 'ArrowLeft') document.getElementById('prevScene').click();
    if (e.key.toLowerCase() === 't') document.getElementById('toggleText').click();
  });
})();
</script>
</body>
</html>
